app:
  name: robot-ingest
  environment: dev
  timezone: "Asia/Shanghai"

mqtt:
  brokerUrl: "tcp://192.168.123.61:1883"
  clientIdPrefix: "ingest-"
  cleanSession: true
  connectionTimeoutSec: 30    # ğŸš€ ä¼˜åŒ–ï¼šå¢åŠ è¿æ¥è¶…æ—¶
  keepAliveSec: 60           # ğŸš€ ä¼˜åŒ–ï¼šå¢åŠ å¿ƒè·³é—´éš”ï¼Œå‡å°‘ç½‘ç»œå¼€é”€
  maxInflight: 10000         # ğŸš€ ä¼˜åŒ–ï¼šå‚è€ƒæµ‹è¯•å®¢æˆ·ç«¯ï¼Œä½¿ç”¨10000è€Œé65535
  # å¼ºåˆ¶é«˜é¢‘åœºæ™¯ä½¿ç”¨QoS=1ç¡®ä¿è‡³å°‘ä¼ é€’ä¸€æ¬¡
  qos:
    state: 1        # ğŸš€ ä¼˜åŒ–ï¼šstateä¸»é¢˜æ”¹ä¸ºQoS=1ï¼Œç¡®ä¿é«˜é¢‘æ¶ˆæ¯ä¸ä¸¢å¤±
    connection: 1
    networkIp: 1
    error: 1
    cargo: 1        # ğŸš€ ä¼˜åŒ–ï¼šcargoä¸»é¢˜ä¹Ÿæ”¹ä¸ºQoS=1
  topics:
    state: "robots/+/state"
    connection: "robots/+/connection"
    networkIp: "robots/+/network/ip"
    error: "robots/+/error"
    cargo: "robots/+/cargo"
  lwt:
    enabled: true
    topicTemplate: "robots/{deviceId}/connection"
    offlinePayload: '{"connection":"offline"}'
    qos: 1
    retain: true
  reconnectBackoff:
    initialMs: 500
    maxMs: 10000
    multiplier: 2.0

redis:
  host: "192.168.123.20"
  port: 6379
  db: 0
  timeoutMs: 2000
  keys:
    latestTemplate: "robot:latest:{deviceId}"
    coreHashTemplate: "robot:corehash:{deviceId}"
    dupsTemplate: "robot:dups:{deviceId}"
  queues:
    state: "q:state"
    connection: "q:connection"
    networkIp: "q:network_ip"
    error: "q:error"
    cargo: "q:cargo"
  metricsKey: "ingest:metrics"
  stream:
    useStream: false
    consumerGroup: "writer-group"
    consumerName: "writer-1"
    maxLen: 1000000

mongodb:
  uri: "mongodb://192.168.123.46:27017"
  database: "robotdb"
  collections:
    latest: "robot_latest_state"
    stateEvents: "state_events"
    connectionEvents: "connection_events"
    networkIpEvents: "network_ip_events"
    errorEvents: "error_events"
    cargoEvents: "cargo_events"
    ingestMetrics: "ingest_metrics"
  writeConcern:
    w: 1
    j: false
    wtimeoutMs: 0

dedupe:
  enable: true  # ğŸš€ å¯ç”¨å»é‡åŠŸèƒ½
  positionQuantize:
    decimals: 6
  coreFields:
    - "battery"
    - "taskStatus"
    - "taskId"
    - "autonomousMode"
    - "fault"
    - "binsNum"
    - "coordinateType"
    - "position"
  hashAlgo: "murmur3"
  dropCounterField: "state_dropped"
  perTopic:
    state:
      coreFields: ["battery","taskStatus","taskId","autonomousMode","fault","binsNum","coordinateType","position"]
      positionQuantize: { decimals: 6 }
      timeWindowMinutes: 10
    connection:
      coreFields: []
      timeWindowMinutes: 10
    networkIp:
      coreFields: ["ip"]
      timeWindowMinutes: 10
    error:
      coreFields: ["code","msg"]
      timeWindowMinutes: 1
    cargo:
      coreFields: ["bins","door"]
      timeWindowMinutes: 10

logging:
  logAll: false

# ğŸš€ è‡ªé€‚åº”é«˜é¢‘å¤„ç†é…ç½®
adaptive:
  enable: true
  # æ¶ˆæ¯å¤§å°é™åˆ¶
  maxMessageSizeKB: 16
  # ååé‡é˜ˆå€¼ (messages/second)
  thresholds:
    normalToHighFreq: 1000    # è¶…è¿‡1000 msg/sè¿›å…¥é«˜é¢‘æ¨¡å¼
    highFreqToNormal: 500     # ä½äº500 msg/sé€€å‡ºé«˜é¢‘æ¨¡å¼
  # ç»Ÿè®¡çª—å£æ—¶é—´
  statisticsWindow:
    entranceIntervalSec: 2    # å…¥å£ç»Ÿè®¡é—´éš”
    exitIntervalSec: 5        # å‡ºå£ç»Ÿè®¡é—´éš”
  # æ¶ˆæ¯é˜Ÿåˆ—é…ç½®
  messageQueue:
    maxSize: 5000             # å†…å­˜é˜Ÿåˆ—æœ€å¤§å®¹é‡
    batchSize: 100            # æ‰¹å¤„ç†å¤§å°
    timeoutMs: 100            # æ‰¹å¤„ç†è¶…æ—¶æ—¶é—´
    bufferSizeKB: 16          # å•ä¸ªæ¶ˆæ¯ç¼“å†²åŒºå¤§å°
  # é«˜é¢‘æ¨¡å¼é…ç½®
  highFreqMode:
    enableSimplifiedLogging: true    # å¯ç”¨ç®€åŒ–æ—¥å¿—
    dedupeStrategy: "batch"          # æ‰¹é‡å»é‡ç­–ç•¥
    skipDetailedStats: true          # è·³è¿‡è¯¦ç»†ç»Ÿè®¡
    logIntervalSec: 10               # æ—¥å¿—è¾“å‡ºé—´éš”

batch:
  sizeTrigger: 1000
  timeTriggerSec: 60
  maxPerFlush: 5000
  backpressure:
    sleepMsOnBusy: 50

http:
  port: 8080
  managementPort: 8081
  actuator:
    enabled: true
    endpoints:
      - "health"
      - "metrics"
      - "prometheus"

logging:
  level: "DEBUG"
  level.com.ibcai.ingest: "DEBUG"
  level.com.ibcai.writer: "DEBUG"
  redact:
    secrets: true
